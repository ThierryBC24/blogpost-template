---
layout: post
title: Milestone 1
---
# Acquisition de données

## Question 1

Cette section explique comment télécharger les données play-by-play de la NHL pour plusieurs saisons. Le but est de récupérer les données d'une saison spécifique via l'API de la NHL, de les enregistrer localement, et de les charger pour une utilisation ultérieure.

### Classe PlayByPlayData
La classe PlayByPlayData a trois fonctionnalités principales :

* **Téléchargement des données pour une saison spécifique** <br />
Via la fonction get_data, vous pouvez télécharger les données de jeu d'une saison (ou les charger depuis un fichier local si elles sont déjà téléchargées).
* **Combinaison des données sur plusieurs saisons** <br />
La méthode get_all_data permet de combiner toutes les données stockées localement en un seul DataFrame.
* **Surcharge de l'opérateur d'addition** <br />
La surcharge permet de facilement fusionner les données de deux instances de PlayByPlayData en utilisant l'opérateur +.

#### **Fonctionnement interne**
La classe PlayByPlayData est conçue pour interagir avec l'API de la NHL et gérer efficacement les données play-by-play. Nous allons voir plus en détail le fonctionnement de la méthode clé de téléchargement des données : fetch_season_data. Cette méthode est responsable de récupérer les données de jeu pour une saison spécifique directement depuis l'API de la NHL. Elle fonctionne en parcourant tous les matchs de la saison pour deux types de partie: la saison régulière (game_type = '02') et les séries éliminatoires (game_type = '03'). Voici les étapes de cette méthode :

* **Boucle sur les matchs :** Pour chaque type de match, elle parcourt tous les identifiants de match, allant de 0001 à 9999, en formatant chaque numéro avec des zéros initiaux pour qu'il corresponde à l'URL de l'API.
* **Construire l'URL de l'API :** L'URL spécifique à chaque match est construite en combinant la saison, le type de match, et le numéro de match. Par exemple, l'URL d'un match de saison régulière de la saison 2022-2023 pourrait ressembler à ```https://api-web.nhle.com/v1/gamecenter/2022020001/play-by-play```.
* **Faire la requête à l'API :** La méthode envoie une requête HTTP GET à l'API de la NHL. Si la requête réussit (statut 200), les données du match sont stockées dans une liste.
* **Condition d'arrêt :** La boucle continue jusqu'à atteindre le numéro de match maximum (9999). Bien que la plupart des saisons comportent beaucoup moins de matchs, l'ordre des identifiants de match n'est pas garanti, il faut donc faire un 'scan' sur l'ensemble des identifiants possibles pour s'assurer que tous les matchs sont récupérés.
* **Convertir en DataFrame :** Une fois tous les matchs d'une saison téléchargés, la liste des données est convertie en un DataFrame pandas.


#### **Comment l'utiliser**
#### **Étape 1 :** Initialiser la classe avec un chemin de base
Le chemin de base est le répertoire dans lequel vous souhaitez stocker les fichiers CSV des saisons téléchargées. Si ce répertoire n'existe pas encore, il sera créé automatiquement.
```
from play_by_play import PlayByPlayData

# Initialiser la classe avec le chemin de base pour stocker les données
base_path = "./nhl_data"
pbp_data = PlayByPlayData(base_path)
```

#### **Étape 2:** Télécharger les données pour une saison spécifique
Pour télécharger les données d'une saison, utilisez la méthode get_data. Vous devez spécifier la saison en indiquant l'année de début (par exemple, 2022 pour la saison 2022-2023).
```
# Télécharger les données pour la saison 2022-2023
data_2022 = pbp_data.get_data(2022)
```
Si les données sont déjà présentes dans le répertoire local, elles seront chargées directement à partir du fichier CSV existant, évitant ainsi un nouveau téléchargement.

#### **Étape 3:** Combiner les données de plusieurs saisons
Si vous avez déjà téléchargé plusieurs saisons, vous pouvez utiliser la méthode get_all_data pour combiner toutes les données stockées localement en un seul DataFrame.
```
# Récupérer toutes les données disponibles dans le répertoire local
all_data = pbp_data.get_all_data()
```


## Question 2

# Outil de débogage interactif
Cet outil intéractif permet de sélectionner une saison, un type de match, un match spécifique et un événement de jeu, puis affiche les informations sur le match et visualise
les coordonnées d'un événement de jeu sur une patinoire de hockey (si possible selon l'événement). Il utilise des widgets (ipywidgets) pour contrôler les sélections et mettre à jour l'affichage.

play_widget.py:
```Python3
class PlayWidget:
    def __init__(self, data):
        self.data = data

        # Widgets
        self.season_slider = widgets.IntSlider(
            min=2016, max=2023, description='Season'
        )

        self.game_type_toggle = widgets.ToggleButtons(
            options=['Regular Season', 'Playoffs'], description='Game Type:'
        )

        self.id_slider = widgets.Dropdown(
            options=self.get_valid_game_ids(self.season_slider.value, self.game_type_toggle.value),
            description='Game ID',
        )

        self.event_id_slider = widgets.Dropdown(
            options=self.get_valid_event_ids(self.season_slider.value, self.game_type_toggle.value, self.id_slider.value),
            description='Event ID',
        )

        # Interactive widget display
        self.interactive_display = widgets.interactive(
            self.update_display, 
            season=self.season_slider,
            game_type=self.game_type_toggle,
            id=self.id_slider,
            event_id=self.event_id_slider
        )

    def display(self):
        """Display the interactive widgets."""
        display(self.interactive_display)

    def get_game_type_code(self, game_type):
        return 2 if game_type == 'Regular Season' else 3

    def get_season_code(self, season):
        return int(f'{season}{season + 1}')

    def get_player_name(self, player_id):
        url = f'https://api-web.nhle.com/v1/player/{player_id}/landing'
        response = requests.get(url).json()
        player_name = f"{response['firstName']['default']} {response['lastName']['default']}"

        return player_name

    def get_valid_game_ids(self, season, game_type):
        """Get valid game IDs for a specific season and game type."""
        game_type_code = self.get_game_type_code(game_type)
        season_code = self.get_season_code(season)
        filtered_data = self.data[(self.data['season'] == season_code) & (self.data['gameType'] == game_type_code)]

        return filtered_data['id']

    def get_valid_event_ids(self, season, game_type, game_id):
        """Get valid event IDs for a specific game."""
        game_type_code = self.get_game_type_code(game_type)
        season_code = self.get_season_code(season)
        filtered_data = self.data[(self.data['season'] == season_code) & (self.data['gameType'] == game_type_code) & (self.data['id'] == game_id)]
        plays_str = filtered_data["plays"].iloc[0].replace("'", '"')
        plays = json.loads(plays_str)

        return [play['eventId'] for play in plays]

    def get_valid_plays(self, game_id, season, game_type):
        """Get valid plays for a specific game."""
        game_type_code = self.get_game_type_code(game_type)
        season_code = self.get_season_code(season)
        filtered_data = self.data[(self.data['id'] == game_id) & (self.data['season'] == season_code) & (self.data['gameType'] == game_type_code)]
        plays_str = filtered_data["plays"].iloc[0].replace("'", '"')
        plays = json.loads(plays_str)

        return plays

    def draw_event(self, play):
        """Visualize a play on a hockey rink."""
        plt.figure(figsize=(10, 6))
        rink_image = mpimg.imread("../figures/nhl_rink.png")
        plt.imshow(rink_image, extent=[-100, 100, -42.5, 42.5])
        rink_center_x = rink_image.shape[1] / 2
        rink_center_y = rink_image.shape[0] / 2

        # Draw coordinate if applicable
        if 'details' in play and 'xCoord' in play['details']:
            x = play['details']['xCoord']
            y = play['details']['yCoord']
            plt.scatter(x, y, color='green', s=100)

        # Generate title
        play_type = play['typeDescKey']
        match play_type:
            case "goal":
                scoring_player_id = play['details']['scoringPlayerId']
                scoring_player = self.get_player_name(scoring_player_id)

                goaler_id = play['details']['goalieInNetId']
                goaler = self.get_player_name(goaler_id)
                plt.title(f'{scoring_player} goal agaisnt goaler {goaler}', fontsize=12)

            # [...] other cases

        plt.xlim(-100, 100)
        plt.ylim(-42.5, 42.5)

        plt.xlabel('feet')
        plt.ylabel('feet')
        plt.grid(True, linestyle='--')
        plt.show()

    def print_game_infos(self, season, game_type, id):
        game_type_code = self.get_game_type_code(game_type)
        season_code = self.get_season_code(season)
        filtered_data = self.data[(self.data['season'] == season_code) & (self.data['gameType'] == game_type_code) & (self.data['id'] == id)]
        home_team_info = ast.literal_eval(filtered_data['homeTeam'].iloc[0])
        away_team_info = ast.literal_eval(filtered_data['awayTeam'].iloc[0])

        home_team_name = home_team_info['abbrev']
        away_team_name = away_team_info['abbrev']

        home_score = home_team_info['score']
        away_score = away_team_info['score']

        home_sog = home_team_info['sog']
        away_sog = away_team_info['sog']

        print(f"Date: {filtered_data["gameDate"].iloc[0]}")
        print(f"Home Team: {home_team_name}, Score: {home_score}, SOG: {home_sog}")
        print(f"Away Team: {away_team_name}, Score: {away_score}, SOG: {away_sog}")

    def update_display(self, season, game_type, id, event_id):
        """Update the displayed data based on widget inputs."""        
        # Update sliders options
        self.id_slider.options = self.get_valid_game_ids(season, game_type)
        self.event_id_slider.options = self.get_valid_event_ids(season, game_type, id)

        # Update valid plays
        plays = self.get_valid_plays(self.id_slider.value, season, game_type)
        selected_play = next(play for play in plays if play['eventId'] == event_id)

        # Display usefull infos
        clear_output()
        self.print_game_infos(season, game_type, id)

        # Draw selected play
        self.draw_event(selected_play)
```

![Image](/images/widget.png)


# Nettoyer les données

## Question 1

![Dataframe](tableau_hockey_clean.png)

## Question 2

On pourrait déduire la force réelle d'une équipe en regardant les événements de punition `"penalty"`. Par exemple, si un joueur de l'équipe A obtient une punition d'une minute `"duration"`, on sait que l'équipe A aura un joueur de moins pendant une minute à partir du moment où la punition est arrivée. On dira que l'équipe A est en désavantage numérique et que l'équipe B est en avantage numérique, en supposant qu'ils étaient à force égale avant la punition.

## Question 3

On pourrait ajouter les caractéristiques suivantes:
* Nombre de buts/tirs au but du joueur
* Temps depuis le dernier tir/but
* Si un but est égalisateur 

Pour le nombre de tirs au but du joueur, on ajoute 1 à chaque fois que ce joueur tir au but. On fait pareillement pour le nombre de buts.

Pour le temps depuis le dernier but, on trouve la différence entre le temps du dernier but et le temps du but actuel. On fait pareillement pour les tirs.

Pour savoir si un but est égalisateur, le nombre de buts de chaque équipe doit être le même.

# Visualisations simples

# Visualisations avancées